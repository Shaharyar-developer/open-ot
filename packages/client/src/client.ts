import { OTType, TransportAdapter } from "@open-ot/core";

export interface OTClientOptions<Snapshot, Op> {
  type: OTType<Snapshot, Op>;
  initialRevision: number;
  initialSnapshot: Snapshot;
  transport?: TransportAdapter;
}

type ClientState = "Synchronized" | "AwaitingConfirm" | "AwaitingWithBuffer";

interface MessageProtocol<Op> {
  type: "op" | "ack";
  op?: Op;
  revision?: number;
}

export class OTClient<Snapshot, Op> {
  private type: OTType<Snapshot, Op>;
  private revision: number;
  private snapshot: Snapshot;
  private state: ClientState;
  private transport: TransportAdapter | null = null;

  // Pending operation (sent to server, waiting for ACK)
  private pendingOp: Op | null = null;

  // Buffer operation (local edits while waiting for ACK)
  private bufferOp: Op | null = null;

  constructor(options: OTClientOptions<Snapshot, Op>) {
    this.type = options.type;
    this.revision = options.initialRevision;
    this.snapshot = options.initialSnapshot;
    this.state = "Synchronized";

    if (options.transport) {
      this.transport = options.transport;
      this.transport.connect(this.handleMessage.bind(this));
    }
  }

  private handleMessage(msg: unknown) {
    const message = msg as MessageProtocol<Op>;

    if (message.type === "ack") {
      this.serverAck();
    } else if (message.type === "op" && message.op) {
      this.applyRemote(message.op);
    }
  }

  private sendOperation(op: Op) {
    if (this.transport) {
      this.transport.send({
        type: "op",
        op: op,
        revision: this.revision,
      });
    }
  }

  /**
   * Apply a local operation generated by the user.
   * Returns the operation that should be sent to the server, or null if buffering.
   */
  public applyLocal(op: Op): Op | null {
    this.snapshot = this.type.apply(this.snapshot, op);

    switch (this.state) {
      case "Synchronized":
        this.pendingOp = op;
        this.state = "AwaitingConfirm";
        this.sendOperation(op);
        return op;

      case "AwaitingConfirm":
        this.bufferOp = op;
        this.state = "AwaitingWithBuffer";
        return null;

      case "AwaitingWithBuffer":
        if (!this.bufferOp)
          throw new Error("Invalid state: AwaitingWithBuffer but no bufferOp");
        this.bufferOp = this.type.compose(this.bufferOp, op);
        return null;
    }
  }

  /**
   * Handle an acknowledgement from the server.
   * Call this when the server confirms reception of the last sent operation.
   * Returns the next operation to send (if any), or null.
   */
  public serverAck(): Op | null {
    this.revision++;

    switch (this.state) {
      case "Synchronized":
        throw new Error("Cannot call serverAck in Synchronized state");

      case "AwaitingConfirm":
        this.pendingOp = null;
        this.state = "Synchronized";
        return null;

      case "AwaitingWithBuffer":
        this.pendingOp = this.bufferOp;
        this.bufferOp = null;
        this.state = "AwaitingConfirm";
        if (this.pendingOp) {
          this.sendOperation(this.pendingOp);
        }
        return this.pendingOp;
    }
  }

  /**
   * Apply a remote operation from the server.
   * Returns the operation that should be applied to the local document (transformed).
   */
  public applyRemote(op: Op): Op {
    this.revision++;

    switch (this.state) {
      case "Synchronized":
        this.snapshot = this.type.apply(this.snapshot, op);
        return op;

      case "AwaitingConfirm": {
        if (!this.pendingOp)
          throw new Error("Invalid state: AwaitingConfirm but no pendingOp");

        // Transform the pending local operation against the incoming remote operation.
        // The remote operation is considered canonical, so the pending operation must be rebased
        // to apply after the remote operation.

        const pendingPrime = this.type.transform(this.pendingOp, op, "right");
        const remotePrime = this.type.transform(op, this.pendingOp, "left");

        this.pendingOp = pendingPrime;
        this.snapshot = this.type.apply(this.snapshot, remotePrime);
        return remotePrime;
      }

      case "AwaitingWithBuffer": {
        if (!this.pendingOp)
          throw new Error("Invalid state: AwaitingWithBuffer but no pendingOp");
        if (!this.bufferOp)
          throw new Error("Invalid state: AwaitingWithBuffer but no bufferOp");

        // 1. Transform pending vs remote
        const pendingPrime2 = this.type.transform(this.pendingOp, op, "right");
        const remotePrime2 = this.type.transform(op, this.pendingOp, "left");

        // 2. Transform buffer vs remote'
        const bufferPrime = this.type.transform(
          this.bufferOp,
          remotePrime2,
          "right"
        );
        const remotePrime3 = this.type.transform(
          remotePrime2,
          this.bufferOp,
          "left"
        );

        this.pendingOp = pendingPrime2;
        this.bufferOp = bufferPrime;
        this.snapshot = this.type.apply(this.snapshot, remotePrime3);

        return remotePrime3;
      }
    }
  }

  public getSnapshot(): Snapshot {
    return this.snapshot;
  }

  public getRevision(): number {
    return this.revision;
  }
}
